/* tslint:disable */
/* eslint-disable */
/**
 * HTI Bot API
 * Interact with the HTI Bot Backend
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BaseErrorModel
 */
export interface BaseErrorModel {
    /**
     * HTTP Status Code
     * @type {number}
     * @memberof BaseErrorModel
     */
    'resultCode'?: number;
    /**
     * Error Message
     * @type {string}
     * @memberof BaseErrorModel
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface BaseSuccessModel
 */
export interface BaseSuccessModel {
    /**
     * HTTP Status Code
     * @type {number}
     * @memberof BaseSuccessModel
     */
    'resultCode'?: number;
}
/**
 * 
 * @export
 * @interface GetAnswer200Response
 */
export interface GetAnswer200Response {
    /**
     * The result code
     * @type {number}
     * @memberof GetAnswer200Response
     */
    'resultCode'?: number;
    /**
     * The answer to the users prompt.
     * @type {string}
     * @memberof GetAnswer200Response
     */
    'answer'?: string;
    /**
     * Whether the system decided to close the conversation automatically
     * @type {boolean}
     * @memberof GetAnswer200Response
     */
    'autoClosedConversation'?: boolean;
    /**
     * If the system has closed the conversation, an incident report on the conversation is generated.
     * @type {string}
     * @memberof GetAnswer200Response
     */
    'incidentReport'?: string;
}
/**
 * 
 * @export
 * @interface HasOpenConversation200Response
 */
export interface HasOpenConversation200Response {
    /**
     * The result code
     * @type {number}
     * @memberof HasOpenConversation200Response
     */
    'resultCode'?: number;
    /**
     * Whether the user has an unclosed conversation and did not request further conversation.
     * @type {boolean}
     * @memberof HasOpenConversation200Response
     */
    'hasOpenConversation'?: boolean;
}
/**
 * Enumeration of supported languages
 * @export
 * @enum {string}
 */

export const LanguageEnum = {
    English: 'English',
    French: 'French',
    Italian: 'Italian',
    German: 'German'
} as const;

export type LanguageEnum = typeof LanguageEnum[keyof typeof LanguageEnum];


/**
 * 
 * @export
 * @interface RateConversation200Response
 */
export interface RateConversation200Response {
    /**
     * The result code
     * @type {number}
     * @memberof RateConversation200Response
     */
    'resultCode'?: number;
    /**
     * If the user has closed the conversation, an incident report on the conversation is generated.
     * @type {string}
     * @memberof RateConversation200Response
     */
    'incidentReport'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Requests further conversation in the ongoing conversation enabling to follow-up on messages.
         * @summary Requests further conversation in the ongoing conversation
         * @param {string} userId The user id as determined by the caller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continueConversation: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('continueConversation', 'userId', userId)
            const localVarPath = `/htibot/continueConversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves relevant internal documentation and generates an answer using a Large Language Model.
         * @summary Retrieves an answer to a user prompt.
         * @param {string} prompt The prompt of the user
         * @param {string} userId The user id as determined by the caller
         * @param {LanguageEnum} language The language for the operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnswer: async (prompt: string, userId: string, language: LanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prompt' is not null or undefined
            assertParamExists('getAnswer', 'prompt', prompt)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAnswer', 'userId', userId)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('getAnswer', 'language', language)
            const localVarPath = `/htibot/getAnswer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (prompt !== undefined) {
                localVarQueryParameter['prompt'] = prompt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A user that has not closed his conversation yet and that has not requested to continue the current conversation has an open conversation.
         * @summary Checks whether user currently has any open conversation with the Bot Backend.
         * @param {string} userId The user id as determined by the caller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasOpenConversation: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('hasOpenConversation', 'userId', userId)
            const localVarPath = `/htibot/hasOpenConversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rates the currently open conversation as positive or negative.
         * @summary Rates the currently open conversation as positive or negative.
         * @param {string} userId The user id as determined by the caller
         * @param {boolean} rating The rating of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateConversation: async (userId: string, rating: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('rateConversation', 'userId', userId)
            // verify required parameter 'rating' is not null or undefined
            assertParamExists('rateConversation', 'rating', rating)
            const localVarPath = `/htibot/rateConversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (rating !== undefined) {
                localVarQueryParameter['rating'] = rating;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Requests further conversation in the ongoing conversation enabling to follow-up on messages.
         * @summary Requests further conversation in the ongoing conversation
         * @param {string} userId The user id as determined by the caller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async continueConversation(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSuccessModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.continueConversation(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.continueConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves relevant internal documentation and generates an answer using a Large Language Model.
         * @summary Retrieves an answer to a user prompt.
         * @param {string} prompt The prompt of the user
         * @param {string} userId The user id as determined by the caller
         * @param {LanguageEnum} language The language for the operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnswer(prompt: string, userId: string, language: LanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAnswer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnswer(prompt, userId, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAnswer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A user that has not closed his conversation yet and that has not requested to continue the current conversation has an open conversation.
         * @summary Checks whether user currently has any open conversation with the Bot Backend.
         * @param {string} userId The user id as determined by the caller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasOpenConversation(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HasOpenConversation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasOpenConversation(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.hasOpenConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rates the currently open conversation as positive or negative.
         * @summary Rates the currently open conversation as positive or negative.
         * @param {string} userId The user id as determined by the caller
         * @param {boolean} rating The rating of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rateConversation(userId: string, rating: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RateConversation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rateConversation(userId, rating, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rateConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Requests further conversation in the ongoing conversation enabling to follow-up on messages.
         * @summary Requests further conversation in the ongoing conversation
         * @param {string} userId The user id as determined by the caller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        continueConversation(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseSuccessModel> {
            return localVarFp.continueConversation(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves relevant internal documentation and generates an answer using a Large Language Model.
         * @summary Retrieves an answer to a user prompt.
         * @param {string} prompt The prompt of the user
         * @param {string} userId The user id as determined by the caller
         * @param {LanguageEnum} language The language for the operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnswer(prompt: string, userId: string, language: LanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetAnswer200Response> {
            return localVarFp.getAnswer(prompt, userId, language, options).then((request) => request(axios, basePath));
        },
        /**
         * A user that has not closed his conversation yet and that has not requested to continue the current conversation has an open conversation.
         * @summary Checks whether user currently has any open conversation with the Bot Backend.
         * @param {string} userId The user id as determined by the caller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasOpenConversation(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<HasOpenConversation200Response> {
            return localVarFp.hasOpenConversation(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rates the currently open conversation as positive or negative.
         * @summary Rates the currently open conversation as positive or negative.
         * @param {string} userId The user id as determined by the caller
         * @param {boolean} rating The rating of the conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateConversation(userId: string, rating: boolean, options?: RawAxiosRequestConfig): AxiosPromise<RateConversation200Response> {
            return localVarFp.rateConversation(userId, rating, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Requests further conversation in the ongoing conversation enabling to follow-up on messages.
     * @summary Requests further conversation in the ongoing conversation
     * @param {string} userId The user id as determined by the caller
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public continueConversation(userId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).continueConversation(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves relevant internal documentation and generates an answer using a Large Language Model.
     * @summary Retrieves an answer to a user prompt.
     * @param {string} prompt The prompt of the user
     * @param {string} userId The user id as determined by the caller
     * @param {LanguageEnum} language The language for the operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAnswer(prompt: string, userId: string, language: LanguageEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAnswer(prompt, userId, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A user that has not closed his conversation yet and that has not requested to continue the current conversation has an open conversation.
     * @summary Checks whether user currently has any open conversation with the Bot Backend.
     * @param {string} userId The user id as determined by the caller
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hasOpenConversation(userId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hasOpenConversation(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rates the currently open conversation as positive or negative.
     * @summary Rates the currently open conversation as positive or negative.
     * @param {string} userId The user id as determined by the caller
     * @param {boolean} rating The rating of the conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rateConversation(userId: string, rating: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rateConversation(userId, rating, options).then((request) => request(this.axios, this.basePath));
    }
}



